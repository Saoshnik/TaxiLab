3. Куда расположить конечные методы - класс Task?
4. IHaveInfo стоит ли реализовать по умолчанию?
7. Как в параметр методов TaxisAssemblies запинуть enum, чтобы было удобно?
8. DbProvider.DEFAULTPATH, почему не static readonly, что лучше?
9. Стоит ли поле id перенести в IHaveInfo

Заменить foreach в static TaxisAssemblyProvider() на метод с делегатами

1. Поменять названия TaxisAssemblyProvider, DbProvider
2. Реализовать GetData() возвращающие отдельные типы: List<BudgetEngine>, List<PremiumCar>... ( c помощью Enum, на подобие Category.Attributes.GetNamedItem("PremiumTaxi") передавая запрос)
4. Добавить возможность сборки Taxi, выбирая по модулям: объект корпус Taxi (свойства Taxi), объект  двигатель (свойства Engine). С помощью Id
5. Поправить остальные свойства и методы в IEngine и ITaxi.
6. В конце добавить вопрос о перезаписи файла xml с конфигурациями всех Taxi
8. Добавить обработку ситуации при которой в TaxisAssemly будут указаны id несуществующие в других xml
9. Возможно стоит Taxi и Engine привести к новому общему типу или переработать ITaxi, добавив IBody, или что-то еще. Но в сборках EngineId и TaxiId разняться, стоит учитывать

// comments
0. Assembly.xml Если надо узнать что за Engine id 0, пускай лезут в Engine.xml. Эти файлы независимы, а связать их с помощью каких-то "пометок" плохая идея
1.  можно добавить генерацию id, но зачем, пока не реализована возможность пользователя. 
Добавлять и создавать новые объекты - это не нужно, давать такую возможность лень, но потом можно попробовать.
2. Поскольку двигатели любого типа мы будем пихать туда и сюда (у них общий интерфейс), то id уникален для общего типа IEngine
3. Для эксперимента оставил id = 0000. в Engines.xml, если нули пропадут значит это сделал toint32
4. Попробовать заменить set на private set, после внедрения чтения с xml
5. Вроде как бы и можно было бы ввести абстрактный класс Parts, но в рамках это программы это только все заметно усложнит. Мы как бы говорим что он есть, но его нет
6. Taxis.Id не используется - ну и ладно


// RealiseInstruction
1. Существуют 3 отдельный xml для: конфигурации Taxi, свойств Taxi, свойств Engine.
2. DbProvider только считывает данные. Считал раз - готово, (частичную обработку) данных лучше оставить другому классу
как и возможность получения каких-то конкретных данных с помощью параметра для метода

3. Тип объекта Taxi определяется математическим округлением его комплектующих Parts, если 50% и(или) более комплектующих - Premium, 
то тип объекта Taxi - PremiumTaxi. Посмотрите следующий пункт!
4. Поскольку ITaxi это независимая структура и Taxis.xml хранит независимые друг от друга компектующие Parts, 
то и речи о том чтобы ввести свойство определяющее тип в интерфейсах ITaxi, IEngine, IBody быть не может, все части интерфейса ITaxi взаименяемы.
Введение свойства определяющие тип отменит независимость и приведет заблуждению.
5. Однако типы для Engine и Body мы берем из файла считая что они достоверны, одной из причиной для этого является то что мы их не вертим как нам захочется, 
как например делаем с Taxi помещая туда модули различных типов. В свою очередь типы Taxi мы определяем основываясь на Parts (см. 3). 
P.S. Но если будет необходимо можно просто переделать как для Engine и Body, либо любым другим способом
6. Поэтому (см. выше) и потому что достать нужный тип из файла Taxis.xml невозможно, так как тип наддо определять по ходу, в зависимости от комплектующих,
в TaxisAssemblyProvider необходимо отдельно хранить все данные в листах общего (ITaxi, IEngine, IBody) и листах конкретного типа (PremiumTaxi, BudgetEngine, PremiumBody)


v 2.0
1. Функциональность Taxi будет обеспечиваться засчет методов из Parts. Убрал PremiumTaxi.cs, BudgetTaxi.cs и создал их копию Taxi.cs без метода SayHi().
2. New
3. как сериализировать атрибуты (отказался, xml остались в версии 1.0)
4. где сохранить значения

5. один класс для де/се-риализации, второй для получения обработанной информации + пара методов
7. Вместо одного метода для сериализации Parts и одного для сериализации Parts, множество методов. Так как параметры по умолчанию не публичны и 
работают автоматически, через static ctor DataProvider
8. Можно ли работаь с общим типом Part в сериализации

9. перешел на сериализацию по типу, если нужен прошлый код - скрин в облаке
10. как лучше поступить с классом TaxiFromXml
11. Добавил extension методы, можно ли без без этих методов написать сериалайзер от общего типа part. 
Не знаю можно ли создать объект типа переменной Type
12. Стоит ли записать методы ToPremiumEngine... в абстрактный класс или оставить их в реализации за счет интерфейсов


v 4.0
1. Стоит ли мне добавлять метод Add в ITaxi и убирать из интерфейса свойство с Parts в класс. Зачем это в Computering.sin

2. Продолжение, два варианта: либо получать объект конкретного класса и писать метод GetPossibleTypes. Либо передавать действие: через делегаты или через реализацию как ToString.